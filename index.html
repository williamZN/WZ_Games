<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Crucigrama ‚Äî Libro de Morm√≥n (Offline v2)</title>
  <meta name="description" content="Crucigrama interactivo (Libro de Morm√≥n) sin dependencias externas." />
  <style>
    :root { --cell: 36px; --border:#e5e7eb; --fg:#111827; --muted:#6b7280; --accent:#2563eb; --bg:#ffffff; --bg2:#f9fafb; --ok:#065f46; --err:#b91c1c; }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial; color: var(--fg); background: #fff; }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 16px; display: grid; grid-template-columns: 1fr; gap: 16px; }
    @media (min-width: 1024px){ .wrap { grid-template-columns: 1fr 1fr; gap: 24px; } }
    h1 { font-size: 20px; margin: 0; }
    h2 { font-size: 18px; margin: 8px 0; }
    h3 { font-size: 14px; margin: 8px 0; }
    .toolbar { display:flex; align-items:center; justify-content:space-between; margin-bottom:8px; gap:8px; flex-wrap:wrap; }
    .btn { padding:8px 12px; border-radius:10px; border:1px solid var(--border); background:#f3f4f6; cursor:pointer; font-size:14px; transition: background .12s ease, transform .08s ease; }
    .btn.primary { background:#2563eb; color:#fff; border-color:#1d4ed8; }
    .btn:hover { filter: brightness(0.97); transform: translateY(-1px); }
    .pill { padding:4px 8px; background:#eef2ff; color:#1e3a8a; border-radius:999px; font-size:13px; border:1px solid #c7d2fe; }
    .grid { display: grid; border:1px solid var(--border); width: max-content; }
    .cell { width: var(--cell); height: var(--cell); display:flex; align-items:center; justify-content:center; border:1px solid var(--border); user-select:none; position: relative;
            transition: background .12s ease, transform .08s ease, box-shadow .12s ease; }
    .cell.block { background:#111827; }
    .cell .val { font-weight:600; font-size: 18px; transition: color .12s ease, transform .08s ease; }
    .cell .num { position:absolute; top:2px; left:4px; font-size: 10px; color:#6b7280; }
    .cell:not(.block):hover { background:#eef2ff; box-shadow: inset 0 0 0 2px #bfdbfe; transform: translateY(-1px); }
    .active-word { background:#eff6ff !important; }
    .active-cell { box-shadow: inset 0 0 0 2px #2563eb, 0 2px 6px rgba(37,99,235,.2); transform: scale(1.02); }
    .ok { color: #065f46; }
    .err { color: #b91c1c; }
    .status { margin-top:8px; font-size:14px; color:#374151; }
    .panel { background: var(--bg2); border:1px solid var(--border); border-radius:12px; padding:12px; }
    .clues { display:grid; grid-template-columns: 1fr; gap:16px; }
    @media (min-width: 768px){ .clues { grid-template-columns: 1fr 1fr; } }
    .clue { padding:8px; border-radius:8px; border:1px solid transparent; cursor:pointer; transition: background .12s ease, border-color .12s ease; }
    .clue:hover { background:#f8fafc; }
    .clue.active { border-color:#93c5fd; background:#eff6ff; }
    .muted { color: var(--muted); }
    .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,.4); display:flex; align-items:center; justify-content:center; }
    .modal { background:#fff; border-radius:16px; box-shadow:0 10px 40px rgba(0,0,0,.15); width: 95vw; max-width: 640px; padding:16px; }
    table { width:100%; border-collapse: collapse; }
    th, td { text-align:left; padding:6px 8px; border-bottom:1px solid var(--border); font-size:14px; }
    .kbd { padding:0 4px; border:1px solid var(--border); border-radius:6px; }
    .row { display:flex; align-items:center; gap:8px; }
    .hidden { display:none; }
    .linklike { color:#2563eb; cursor:pointer; text-decoration: underline; }
  </style>
</head>
<body>
  <div class="wrap">
    <div>
      <div class="toolbar">
        <div class="row"><h1>Crucigrama ‚Äî Libro de Morm√≥n (Offline v2)</h1></div>
        <div class="row">
          <span class="pill" id="timer">‚è± 00:00</span>
          <button class="btn" id="btnRecords">üèÜ R√©cords</button>
        </div>
      </div>
      <div class="row" style="gap:8px; flex-wrap:wrap; margin-bottom:12px">
        <button class="btn primary" id="btnNew">üîÄ Nueva mezcla</button>
        <button class="btn" id="btnDir">üß≠ Direcci√≥n: <b id="dirLabel">Horizontal</b></button>
        <button class="btn" id="btnClear">üßπ Limpiar</button>
        <button class="btn" id="btnValidate">‚úÖ Validar</button>
        <button class="btn" id="btnRevealLetter">üëÅ Revelar letra</button>
        <button class="btn" id="btnRevealWord">üëÅ Revelar palabra</button>
        <button class="btn" id="btnRevealAll">üëÅ Revelar todo</button>
      </div>
      <div id="gridHost" class="grid"></div>
      <div class="status" id="status">
        <span class="muted">Tip: <span class="kbd">Espacio</span> cambia direcci√≥n, <span class="kbd">Tab</span> va a la siguiente pista.</span>
      </div>
    </div>
    <div>
      <div class="toolbar">
        <h2>Pistas</h2>
        <div class="muted" id="meta"></div>
      </div>
      <div class="clues">
        <div>
          <h3>Horizontales</h3>
          <div id="cluesAcross"></div>
        </div>
        <div>
          <h3>Verticales</h3>
          <div id="cluesDown"></div>
        </div>
      </div>
      <div class="panel" style="margin-top:8px">
        <div class="muted">Banco de palabras ampliado (55+ t√©rminos del Libro de Morm√≥n). Respuestas sin tildes para facilitar el input.</div>
      </div>
    </div>
  </div>

  <div class="modal-backdrop hidden" id="recordsModal">
    <div class="modal">
      <div class="toolbar">
        <h3>Centro de R√©cords</h3>
        <button class="btn" id="btnCloseRecords">Cerrar</button>
      </div>
      <div id="lastResult" class="panel hidden"></div>
      <div class="muted" style="margin-bottom:6px">Mejores tiempos (top 10):</div>
      <div style="max-height:260px; overflow:auto; border:1px solid var(--border); border-radius:12px;">
        <table>
          <thead><tr><th>Tiempo</th><th>Tama√±o</th><th>Palabras</th><th>Fecha</th></tr></thead>
          <tbody id="recRows"></tbody>
        </table>
      </div>
      <div class="muted" style="margin-top:8px">Los r√©cords se guardan localmente en tu navegador.</div>
    </div>
  </div>

  <script>
  function sanitize(raw){ return raw.toUpperCase().normalize("NFD").replace(/[ÃÄ-ÕØ]/g,"").replace(/[^A-Z]/g,""); }
  function rngShuffle(arr){ const a=[...arr]; for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
  function fmtSecs(total){ const mm=String(Math.floor(total/60)).padStart(2,"0"); const ss=String(total%60).padStart(2,"0"); return mm+":"+ss; }
  const STORAGE_KEY="BOM_XWORD_RECORDS_V1";
  function loadRecords(){ try{ const raw=localStorage.getItem(STORAGE_KEY); return raw?JSON.parse(raw):[];}catch{return [];} }
  function saveRecords(r){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(r)); }catch{} }
  function bestForSize(recs, size){ const xs=recs.filter(r=>r.size===size); if(xs.length===0) return null; return xs.reduce((a,b)=>a.seconds<=b.seconds?a:b); }

  const WORD_BANK = [
    { answer: "NEFI", clue: "Primer profeta y narrador al inicio del libro." },
    { answer: "LAMAN", clue: "Hijo mayor de Lehi, hermano de Nefi." },
    { answer: "LEMUEL", clue: "Hermano de Nefi que murmuraba junto con Lam√°n." },
    { answer: "LIAHONA", clue: "Instrumento dado a Lehi para guiar en el desierto." },
    { answer: "ZARAHEMLA", clue: "Ciudad principal donde gobernaron los jueces." },
    { answer: "HELAMAN", clue: "L√≠der de los dos mil j√≥venes guerreros." },
    { answer: "MOSIAH", clue: "Rey que tradujo registros antiguos." },
    { answer: "MORONI", clue: "√öltimo profeta que enterr√≥ las planchas." },
    { answer: "MORMON", clue: "Historiador y compilador del registro." },
    { answer: "CUMORAH", clue: "Colina donde se ocultaron las planchas." },
    { answer: "GADIANTON", clue: "L√≠der de las combinaciones secretas." },
    { answer: "ABINADI", clue: "Profeta que testific√≥ ante el rey No√©." },
    { answer: "AMMON", clue: "Misionero que defendi√≥ los reba√±os del rey Lamoni." },
    { answer: "ZORAMITAS", clue: "Pueblo que oraba en el Rame√∫mptom." },
    { answer: "JAREDITAS", clue: "Pueblo antiguo que viaj√≥ en barcos al nuevo mundo." },
    { answer: "DESERET", clue: "Palabra jaredita para 'abeja'." },
    { answer: "TEANCUM", clue: "Guerrero nefita que dio muerte a Amalick√≠a." },
    { answer: "AMULEK", clue: "Compa√±ero de predicaci√≥n de Alma en Ammon√≠ah." },
    { answer: "OMNI", clue: "Libro breve con varios autores." },
    { answer: "ENOS", clue: "Profeta cuya oraci√≥n fue respondida tras luchar todo el d√≠a." },
    { answer: "JACOB", clue: "Hermano de Nefi y autor de un libro." },
    { answer: "ETHER", clue: "Profeta que narra la historia jaredita." },
    { answer: "ALMA", clue: "Profeta y juez que escribi√≥ extensamente." },
    { answer: "LEHI", clue: "Profeta que sali√≥ de Jerusal√©n con su familia." },
    { answer: "SAM", clue: "Hermano leal de Nefi." },
    { answer: "SARIAH", clue: "Esposa de Lehi y madre de Nefi." },
    { answer: "LAMONI", clue: "Rey lamanita convertido por Ammon." },
    { answer: "AMMONIHAH", clue: "Ciudad donde Alma y Amulek predicaron poderosamente." },
    { answer: "ZEEZROM", clue: "Abogado que debati√≥ con Alma y Amulek." },
    { answer: "KORIHOR", clue: "Anticristo que neg√≥ a Dios y pidi√≥ se√±al." },
    { answer: "SHEREM", clue: "Anticristo que disput√≥ con Jacob." },
    { answer: "GIDEON", clue: "Valiente nefita y nombre de una ciudad." },
    { answer: "SIDON", clue: "R√≠o principal mencionado en las guerras." },
    { answer: "RIPLAH", clue: "Colina clave en batallas nefitas." },
    { answer: "JERSHON", clue: "Tierra dada a los anti-nefi-lehitas." },
    { answer: "ANTIONUM", clue: "Tierra de los zoramitas." },
    { answer: "RAMEUMPTOM", clue: "Torrecilla donde oraban los zoramitas." },
    { answer: "HAGOTH", clue: "Constructor de barcos que parti√≥ hacia el norte." },
    { answer: "SHIBLON", clue: "Hijo de Alma que recibi√≥ consejo sobre templanza." },
    { answer: "CORIANTON", clue: "Hijo de Alma que abandon√≥ su ministerio y se arrepinti√≥." },
    { answer: "PAHORAN", clue: "Juez superior durante las guerras." },
    { answer: "PACUMENI", clue: "Hijo de Pahor√°n que lleg√≥ a ser juez superior." },
    { answer: "LACHONEUS", clue: "Gobernante nefita que resisti√≥ a los ladrones." },
    { answer: "GIDGIDDONI", clue: "Comandante justo contra los ladrones de Gadiant√≥n." },
    { answer: "GIDDIANHI", clue: "Jefe de los ladrones que amenaz√≥ a los nefitas." },
    { answer: "KISHKUMEN", clue: "Asesino ligado a las combinaciones secretas." },
    { answer: "ANTION", clue: "Medida de oro en la moneda nefita." },
    { answer: "SENINE", clue: "Unidad monetaria nefita (valor est√°ndar)." },
    { answer: "SEON", clue: "Unidad monetaria nefita (dos senines)." },
    { answer: "SHUM", clue: "Unidad monetaria nefita (seis senines)." },
    { answer: "MANTI", clue: "Ciudad estrat√©gica cercana al r√≠o Sid√≥n." },
    { answer: "NEPHIHAH", clue: "Ciudad construida por los nefitas para defensa." },
    { answer: "ABUNDANCIA", clue: "Tierra tambi√©n llamada Bountiful." },
    { answer: "CUMENI", clue: "Ciudad capturada y recuperada en las guerras." },
    { answer: "MORIANTON", clue: "Nombre de un l√≠der y de una ciudad en disputas fronterizas." },
    { answer: "MORIANCUMER", clue: "Lugar asociado al hermano de Jared." },
    { answer: "CORIANTUMR", clue: "√öltimo rey jaredita mencionado por los nefitas." },
    { answer: "SHULE", clue: "Rey jaredita justo, hijo de Kib." },
    { answer: "ORIHAH", clue: "Primer rey jaredita, hijo de Jared." },
    { answer: "SHARED", clue: "Rey jaredita que luch√≥ contra Coriantumr." },
    { answer: "OMER", clue: "Rey jaredita que huy√≥ por revelaci√≥n." },
    { answer: "MAHONRI", clue: "Nombre revelado del hermano de Jared." },
    { answer: "ZORAM", clue: "Siervo que sali√≥ de Jerusal√©n con los lehitas." },
    { answer: "ANTINEPHILEHI", clue: "Nombre del pueblo pac√≠fico que depuso las armas." }
  ].map(x=>({answer:sanitize(x.answer), clue:x.clue}));

  function makeEmptyGrid(size){ return Array.from({length:size},()=>Array.from({length:size},()=>null)); }
  function inBounds(size,r,c){ return r>=0 && c>=0 && r<size && c<size; }
  function canPlaceWord(grid,size,word,row,col,dir){
    const dr=dir==="down"?1:0, dc=dir==="across"?1:0;
    const endR=row+dr*(word.length-1), endC=col+dc*(word.length-1);
    if(!inBounds(size,row,col)||!inBounds(size,endR,endC)) return false;
    for(let k=0;k<word.length;k++){
      const r=row+dr*k, c=col+dc*k; const cell=grid[r][c];
      if(cell && cell!==word[k]) return false;
      if(!cell){
        if(dir==="across"){ if(inBounds(size,r-1,c)&&grid[r-1][c]) return false; if(inBounds(size,r+1,c)&&grid[r+1][c]) return false; }
        else { if(inBounds(size,r,c-1)&&grid[r][c-1]) return false; if(inBounds(size,r,c+1)&&grid[r][c+1]) return false; }
      }
    }
    const br=row-(dir==="down"?1:0), bc=col-(dir==="across"?1:0);
    const ar=endR+(dir==="down"?1:0), ac=endC+(dir==="across"?1:0);
    if(inBounds(size,br,bc)&&grid[br][bc]) return false;
    if(inBounds(size,ar,ac)&&grid[ar][ac]) return false;
    return true;
  }
  function placeWord(grid, word, row, col, dir){ const dr=dir==="down"?1:0, dc=dir==="across"?1:0; for(let k=0;k<word.length;k++){ grid[row+dr*k][col+dc*k]=word[k]; } }
  function findAllLetterPositions(grid,size,letter){ const list=[]; for(let r=0;r<size;r++){ for(let c=0;c<size;c++){ if(grid[r][c]===letter) list.push({r,c}); } } return list; }

  function generateCrossword(size, entries, maxWords=18){
    const shuffled=rngShuffle(entries).slice(0, Math.min(entries.length,80));
    const grid=makeEmptyGrid(size);
    const placed=[];
    const seed=[...shuffled].sort((a,b)=>b.answer.length-a.answer.length)[0];
    const mid=Math.floor(size/2); const startCol=Math.max(0, Math.floor((size-seed.answer.length)/2));
    placeWord(grid, seed.answer, mid, startCol, "across");
    placed.push({ id:0, dir:"across", row:mid, col:startCol, answer:seed.answer, clue:seed.clue });
    let idCounter=1;
    for(const entry of shuffled.filter(e=>e!==seed)){
      if(placed.length>=maxWords) break;
      const word=entry.answer; const candidates=[];
      for(let i=0;i<word.length;i++){
        const letter=word[i]; const positions=findAllLetterPositions(grid,size,letter);
        for(const pos of positions){
          const ar=pos.r, ac=pos.c-i; if(canPlaceWord(grid,size,word,ar,ac,"across")) candidates.push({dir:"across",row:ar,col:ac});
          const dr=pos.r-i, dc=pos.c; if(canPlaceWord(grid,size,word,dr,dc,"down")) candidates.push({dir:"down",row:dr,col:dc});
        }
      }
      const cand=rngShuffle(candidates);
      if(cand.length>0){ const p=cand[0]; placeWord(grid,word,p.row,p.col,p.dir); placed.push({ id:idCounter++, dir:p.dir, row:p.row, col:p.col, answer:word, clue:entry.clue }); continue; }
      let done=false;
      for(let r=0;r<size && !done;r++){
        for(let c=0;c<size && !done;c++){
          for(const d of ["across","down"]){
            if(canPlaceWord(grid,size,word,r,c,d)){ placeWord(grid,word,r,c,d); placed.push({ id:idCounter++, dir:d, row:r, col:c, answer:word, clue:entry.clue }); done=true; break; }
          }
        }
      }
    }
    const cells=[]; for(let r=0;r<size;r++){ for(let c=0;c<size;c++){ cells.push({r,c, solution:grid[r][c], value:"", block:grid[r][c]==null}); } }
    const wordCells=new Map(); const key=(r,c)=>`${r},${c}`;
    placed.forEach(w=>{ const dr=w.dir==="down"?1:0, dc=w.dir==="across"?1:0; for(let k=0;k<w.answer.length;k++){ const r=w.row+dr*k, c=w.col+dc*k; const kk=key(r,c); const obj=wordCells.get(kk)||{}; obj[w.dir]=w.id; wordCells.set(kk,obj); }});
    let number=1; const acrossClues=[], downClues=[]; const idToNumber=new Map();
    placed.forEach(w=>{ const dr=w.dir==="down"?1:0, dc=w.dir==="across"?1:0; const br=w.row-dr, bc=w.col-dc; const isStart=!inBounds(size,br,bc)||grid[br][bc]==null;
      if(isStart){ idToNumber.set(w.id, number); (w.dir==="across"?acrossClues:downClues).push({number, clue:w.clue, id:w.id, answer:w.answer}); number++; } });
    return { size, cells, placed, idToNumber, acrossClues: acrossClues.sort((a,b)=>a.number-b.number), downClues: downClues.sort((a,b)=>a.number-b.number), wordCells };
  }

  const state = { size: 13, puzzle: null, activeDir:"across", activeCell:null, activeWordId:null, showErrors:false, running:true, seconds:0, solvedFlag:false, records: loadRecords(), lastResult:null };

  function startTimer(){ if(state._t) clearInterval(state._t); state._t=setInterval(()=>{ if(state.running){ state.seconds++; renderTimer(); }},1000); }
  function renderTimer(){ document.getElementById("timer").textContent = "‚è± " + fmtSecs(state.seconds); }

  function init(){
    rebuild();
    startTimer();
    document.getElementById("btnNew").onclick = ()=>rebuild();
    document.getElementById("btnDir").onclick = ()=>{ state.activeDir = (state.activeDir==="across"?"down":"across"); document.getElementById("dirLabel").textContent = state.activeDir==="across"?"Horizontal":"Vertical"; updateClueHighlight(); };
    document.getElementById("btnClear").onclick = ()=>{ state.puzzle.cells.forEach(c=>c.value=""); state.showErrors=false; paintGrid(); };
    document.getElementById("btnValidate").onclick = ()=>{ state.showErrors=true; paintGrid(); checkSolved(); };
    document.getElementById("btnRevealLetter").onclick = ()=>reveal("letter");
    document.getElementById("btnRevealWord").onclick = ()=>reveal("word");
    document.getElementById("btnRevealAll").onclick = ()=>reveal("puzzle");
    document.getElementById("btnRecords").onclick = showRecords;
    document.getElementById("btnCloseRecords").onclick = ()=>document.getElementById("recordsModal").classList.add("hidden");
    window.addEventListener("keydown", onKeyDown);
  }

  function rebuild(){
    const pool = WORD_BANK.map(w=>({answer: sanitize(w.answer), clue: w.clue}));
    state.puzzle = generateCrossword(state.size, pool, 18);
    state.activeDir = "across";
    state.activeWordId = state.puzzle.acrossClues[0]?.id ?? state.puzzle.downClues[0]?.id ?? null;
    state.activeCell = null;
    state.showErrors = false;
    state.seconds = 0;
    state.running = true;
    state.lastResult = null;
    paintGrid();
    renderMeta();
    renderTimer();
    updateStatus();
    updateClueHighlight();
  }

  function renderMeta(){
    const m = document.getElementById("meta");
    m.textContent = `Tama√±o: ${state.puzzle.size}√ó${state.puzzle.size} ¬∑ Palabras: ${state.puzzle.acrossClues.length + state.puzzle.downClues.length}`;
    renderClues();
  }

  function renderClues(){
    const a = document.getElementById("cluesAcross"); const d = document.getElementById("cluesDown");
    a.innerHTML = ""; d.innerHTML = "";
    for(const c of state.puzzle.acrossClues){
      const btn = document.createElement("div");
      btn.className = "clue";
      btn.dataset.id = c.id; btn.dataset.dir = "across";
      btn.textContent = `${c.number}. ${c.clue}`;
      btn.onclick = ()=>{ state.activeDir="across"; state.activeWordId=c.id; const w=state.puzzle.placed.find(w=>w.id===c.id); state.activeCell = w.row*state.puzzle.size + w.col; paintGrid(); updateClueHighlight(); };
      a.appendChild(btn);
    }
    for(const c of state.puzzle.downClues){
      const btn = document.createElement("div");
      btn.className = "clue";
      btn.dataset.id = c.id; btn.dataset.dir = "down";
      btn.textContent = `${c.number}. ${c.clue}`;
      btn.onclick = ()=>{ state.activeDir="down"; state.activeWordId=c.id; const w=state.puzzle.placed.find(w=>w.id===c.id); state.activeCell = w.row*state.puzzle.size + w.col; paintGrid(); updateClueHighlight(); };
      d.appendChild(btn);
    }
    updateClueHighlight();
  }

  function updateClueHighlight(){
    const acrossHost = document.getElementById("cluesAcross");
    const downHost = document.getElementById("cluesDown");
    for(const host of [acrossHost, downHost]){
      host.querySelectorAll(".clue").forEach(el=>{
        const id = Number(el.dataset.id);
        const dir = el.dataset.dir;
        const active = (id===state.activeWordId) && (dir===state.activeDir);
        el.classList.toggle("active", active);
      });
    }
  }

  function keyOfCell(cell){ return `${cell.r},${cell.c}`; }
  function getWordCells(w){ const list=[]; const dr=w.dir==="down"?1:0, dc=w.dir==="across"?1:0; for(let k=0;k<w.answer.length;k++){ list.push((w.row+dr*k)*state.puzzle.size + (w.col+dc*k)); } return list; }

  function paintGrid(){
    const host = document.getElementById("gridHost");
    host.style.gridTemplateColumns = `repeat(${state.puzzle.size}, var(--cell))`;
    host.style.gridTemplateRows = `repeat(${state.puzzle.size}, var(--cell))`;
    host.innerHTML = "";
    const activeWord = state.activeWordId==null ? null : state.puzzle.placed.find(w=>w.id===state.activeWordId);
    const activeWordCells = activeWord ? getWordCells(activeWord) : [];
    state.puzzle.cells.forEach((cell, idx)=>{
      const el = document.createElement("div");
      const isActiveWordCell = activeWordCells.includes(idx);
      const isActiveCell = state.activeCell===idx;
      el.className = "cell" + (cell.block ? " block" : "") + (isActiveWordCell && !cell.block ? " active-word" : "") + (isActiveCell && !cell.block ? " active-cell" : "");
      el.onclick = ()=>{ focusCell(idx); };
      if(!cell.block){
        const span = document.createElement("span");
        const wrong = state.showErrors && cell.value && cell.value !== cell.solution;
        const solvedCell = cell.value && cell.value === cell.solution;
        span.className = "val " + (wrong ? "err" : solvedCell ? "ok" : "");
        span.textContent = cell.value || "";
        el.appendChild(span);

        const mapping = state.puzzle.wordCells.get(keyOfCell(cell)) || {};
        const nums = [];
        if(mapping.across != null){
          const wA = state.puzzle.placed.find(x=>x.id===mapping.across);
          if(wA && wA.row===cell.r && wA.col===cell.c){ nums.push(state.puzzle.idToNumber.get(wA.id)); }
        }
        if(mapping.down != null){
          const wD = state.puzzle.placed.find(x=>x.id===mapping.down);
          if(wD && wD.row===cell.r && wD.col===cell.c){ nums.push(state.puzzle.idToNumber.get(wD.id)); }
        }
        if(nums.length){
          const num = Math.min.apply(null, nums);
          const numEl = document.createElement("span");
          numEl.className = "num";
          numEl.textContent = num;
          el.appendChild(numEl);
        }
      }
      host.appendChild(el);
    });
    updateClueHighlight();
  }

  function focusCell(idx){
    state.activeCell = idx;
    const cell = state.puzzle.cells[idx];
    const mapping = state.puzzle.wordCells.get(keyOfCell(cell)) || {};
    const dirId = mapping[state.activeDir] ?? mapping[state.activeDir==="across"?"down":"across"];
    if(dirId!=null) state.activeWordId = dirId;
    paintGrid();
    updateClueHighlight();
  }

  function onKeyDown(e){
    const activeWord = state.activeWordId==null ? null : state.puzzle.placed.find(w=>w.id===state.activeWordId);
    if(!activeWord) return;
    const activeWordCells = getWordCells(activeWord);
    const idx = state.activeCell ?? activeWordCells[0];
    const pos = activeWordCells.indexOf(idx);
    const move = (d)=>{ const ni = activeWordCells[Math.min(Math.max(pos+d,0), activeWordCells.length-1)]; state.activeCell = ni; paintGrid(); updateClueHighlight(); };

    if(e.key==="Tab"){ e.preventDefault(); const list = state.activeDir==="across"?state.puzzle.acrossClues:state.puzzle.downClues; const ii=list.findIndex(c=>c.id===state.activeWordId); const next=list[(ii+1)%list.length]; state.activeWordId=next.id; const w=state.puzzle.placed.find(w=>w.id===next.id); state.activeCell = w.row*state.puzzle.size + w.col; paintGrid(); updateClueHighlight(); return; }
    if(e.key===" "){ e.preventDefault(); state.activeDir = state.activeDir==="across"?"down":"across"; document.getElementById("dirLabel").textContent = state.activeDir==="across"?"Horizontal":"Vertical"; updateClueHighlight(); return; }
    if(e.key==="Backspace"){ e.preventDefault(); const cell=state.puzzle.cells[idx]; cell.value=""; move(-1); return; }
    if(["ArrowLeft","ArrowUp","ArrowRight","ArrowDown"].includes(e.key)){ e.preventDefault(); const horiz=e.key==="ArrowLeft"||e.key==="ArrowRight"; const desired=horiz?"across":"down"; if(state.activeDir!==desired) { state.activeDir=desired; updateClueHighlight(); } move(e.key==="ArrowLeft"||e.key==="ArrowUp"?-1:+1); return; }
    const ch=e.key.toUpperCase(); if(/^[A-Z]$/.test(ch)){ const cell=state.puzzle.cells[idx]; if(!cell.block){ cell.value=ch; move(+1); } return; }
  }

  function reveal(type){
    const activeWord = state.activeWordId==null ? null : state.puzzle.placed.find(w=>w.id===state.activeWordId);
    if(!activeWord) return;
    const activeWordCells = getWordCells(activeWord);
    if(type==="letter"){ const idx=state.activeCell ?? activeWordCells[0]; const cell=state.puzzle.cells[idx]; cell.value = cell.solution ?? ""; }
    else if(type==="word"){ for(const i of activeWordCells){ const cell=state.puzzle.cells[i]; cell.value = cell.solution ?? ""; } }
    else if(type==="puzzle"){ state.puzzle.cells.forEach(c=>c.value=c.solution ?? ""); }
    paintGrid(); checkSolved();
  }

  function checkSolved(){
    const solved = state.puzzle.cells.every(c => (c.block?true: c.value===c.solution));
    if(solved && !state.solvedFlag){
      state.solvedFlag = true;
      state.running = false;
      const rec = { seconds: state.seconds, date: new Date().toISOString(), size: state.puzzle.size, words: state.puzzle.acrossClues.length + state.puzzle.downClues.length };
      const currentBest = bestForSize(state.records, state.puzzle.size);
      const isBest = !currentBest || rec.seconds < currentBest.seconds;
      const updated = [rec, ...state.records].sort((a,b)=>a.seconds-b.seconds).slice(0,50);
      state.records = updated; saveRecords(updated);
      state.lastResult = { rec, isBest };
      updateStatus(); showRecords();
    }
    if(!solved){ state.solvedFlag=false; }
  }

  function updateStatus(){
    const el = document.getElementById("status");
    if(state.solvedFlag){
      el.innerHTML = `
        <div class="panel" style="color:#065f46; border-color:#bbf7d0; background:#f0fdf4">
          ¬°Completado! Tiempo: <b>${fmtSecs(state.seconds)}</b>. <span class="linklike" id="linkRecords">Ver r√©cords</span>
        </div>`;
      document.getElementById("linkRecords").onclick = showRecords;
    }else{
      el.innerHTML = `<span class="muted">Tip: <span class="kbd">Espacio</span> cambia direcci√≥n, <span class="kbd">Tab</span> va a la siguiente pista.</span>`;
    }
  }

  function showRecords(){
    const modal = document.getElementById("recordsModal");
    const rows = document.getElementById("recRows");
    rows.innerHTML = "";
    const list = state.records.slice(0,10);
    if(list.length===0){
      const tr=document.createElement("tr"); tr.innerHTML = `<td colspan="4" style="text-align:center; color:#6b7280; padding:12px">A√∫n no hay r√©cords. ¬°Juega una partida!</td>`; rows.appendChild(tr);
    }else{
      for(const r of list){
        const tr=document.createElement("tr"); tr.innerHTML = `<td><b>${fmtSecs(r.seconds)}</b></td><td>${r.size}√ó${r.size}</td><td>${r.words}</td><td>${new Date(r.date).toLocaleString()}</td>`; rows.appendChild(tr);
      }
    }
    const last = document.getElementById("lastResult");
    if(state.lastResult){
      last.classList.remove("hidden");
      last.textContent = (state.lastResult.isBest ? "¬°Nuevo r√©cord personal! " : "Resultado registrado: ") + `Tiempo ${fmtSecs(state.lastResult.rec.seconds)} ¬∑ Tama√±o ${state.lastResult.rec.size}√ó${state.puzzle.size} ¬∑ Palabras ${state.puzzle.acrossClues.length + state.puzzle.downClues.length}`;
    }else{
      last.classList.add("hidden");
      last.textContent = "";
    }
    modal.classList.remove("hidden");
  }

  init();
  </script>
</body>
</html>
